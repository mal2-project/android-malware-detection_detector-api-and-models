"""Testing the malware_cache module

Requires pytest

To run tests just enter the apk-total directory in terminal and run the command:
pytest -v

To run all tests in a file just add the filename:
pytest -v test_malware_cache.py

To run just a single test in a file, add "::testname" (without quotation marks), for example:
pytest -v test_malware_cache.py::test_FileEntryCache_lookup_count_is_zero
"""

from malware_cache import FileEntry, FileEntryCache
import pytest
import datetime
import psycopg2
from conftest import CONSTANTS as CONS, FILE_ENTRY_EXAMPLES as EX, FailedSetupException

if CONS['CACHE'] is None:
    raise FailedSetupException('no cache in conftest.py')
else:
    CACHE = CONS['CACHE']

# ============================================= helper functions =============================================


# ============================================= testing FileEntry =============================================


class TestFileEntry:
    def test_FileEntry_init_calls_datetime_correctly(self):
        """test if FileEntry calls datetime.datetime.now() exactly once when a FileEntry gets created"""

        mock_entry = FileEntry(filename="doesn't",
                               path="matter",
                               md5="only",
                               sha1="testing",
                               sha256="first_seen",
                               contains_malware=True,
                               contains_trackers=False,
                               contains_adware=False)

        # check if FileEntry.first_seen was set to correct datetime
        assert mock_entry.first_seen == CONS['MOCK_FILE_CREATION_DATETIME']

    @pytest.mark.skip(reason="not implemented yet")
    def test_FileEntry_analyzed_time_calls_datetime_correctly(self):
        # TODO: this is actually done by server.upload_file() => implement test in test_server.py
        pass

    @pytest.mark.xfail(reason="builtin __hash__ should return an int if called from builtin hash() function")
    def test_hashing_FileEntry_(self):
        """tests looking up the hash with __hash__ returns stored sha256 value"""
        test_entry = FileEntry(filename="foo",
                               path="imaginary",
                               md5="123",
                               sha1="234",
                               sha256="012345789ABCDEFGH",
                               contains_malware=True,
                               contains_trackers=False,
                               contains_adware=False)

        # TODO: find solution for the following problem (note calling __hash__ vs calling hash):
        assert test_entry.__hash__() == "012345789ABCDEFGH"  # this works
        assert hash(test_entry) == "012345789ABCDEFGH"  # this fails: builtin __hash__ should always return an int

    @pytest.mark.xfail(reason='test only looks at 1 of 3 caches, how should final test behave?')
    def test_FileEntry_equal(self):
        """compares 2 files with all attributes different except for having the same sha256 value"""
        # TODO: what about md5 and sha1?
        test_entry1 = FileEntry(filename="foo",
                                path="imaginary",
                                md5="1",
                                sha1="2",
                                sha256="ABC123DEF456",
                                contains_malware=True,
                                contains_trackers=False,
                                contains_adware=False)

        test_entry2 = FileEntry(filename="bar",
                                path="real",
                                md5="3",
                                sha1="4",
                                sha256="ABC123DEF456",
                                contains_malware=False,
                                contains_trackers=True,
                                contains_adware=True)

        assert test_entry1 == test_entry2

    @pytest.mark.xfail(reason='test only looks at 1 of 3 caches, how should final test behave?')
    def test_FileEntry_not_equal(self):
        """compares 2 files with all attributes the same except for having the different sha256 value"""
        # TODO: what about md5 and sha1?
        test_entry1 = FileEntry(filename="foo",
                                path="imaginary",
                                md5="1",
                                sha1="2",
                                sha256="ABC123DEF456",
                                contains_malware=True,
                                contains_trackers=False,
                                contains_adware=False)

        test_entry2 = FileEntry(filename="foo",
                                path="imaginary",
                                md5="1",
                                sha1="2",
                                sha256="NOT THE SAME AS OTHER FILE",
                                contains_malware=True,
                                contains_trackers=False,
                                contains_adware=False)

        assert test_entry1 != test_entry2

    def test_FileEntry_dunder_str(self):
        """
        test if __str__ returns correct output with mocked datetime
        note that  'analyzed_at' will always be None for a newly generated FileEntry"""
        test_entry = FileEntry(filename="foo",
                               path="test",
                               md5="1",
                               sha1="2",
                               sha256="ABC123",
                               contains_malware=True,
                               contains_trackers=False,
                               contains_adware=False)

        result = str(test_entry)

        # test for correct output
        assert result == '{"filename": "foo",' \
                         ' "path": "test",' \
                         ' "md5": "1",' \
                         ' "sha1": "2",' \
                         ' "sha256": "ABC123",' \
                         ' "contains_malware": true,' \
                         ' "contains_trackers": false,' \
                         ' "contains_adware": false,' \
                         f''' "first_seen": "{CONS['MOCK_FILE_CREATION_DATETIME']}",''' \
                         ' "analyzed_at": "None"}'

    def test_FileEntry_dunder_repr(self):
        """test if __repr__ returns correct output with mocked datetime"""
        test_entry = FileEntry(filename="foo",
                               path="test",
                               md5="1",
                               sha1="2",
                               sha256="ABC123",
                               contains_malware=True,
                               contains_trackers=False,
                               contains_adware=False)

        # test for correct output
        assert repr(test_entry) == '{"filename": "foo",' \
                                   ' "path": "test",' \
                                   ' "md5": "1",' \
                                   ' "sha1": "2",' \
                                   ' "sha256": "ABC123",' \
                                   ' "contains_malware": true,' \
                                   ' "contains_trackers": false,' \
                                   ' "contains_adware": false,' \
                                   f''' "first_seen": "{CONS['MOCK_FILE_CREATION_DATETIME']}",''' \
                                   ' "analyzed_at": "None"}'

    def test_correct_default_values_on_FileEntry_init(self):
        """Test for correct default values when creating a FileEntry"""
        test_file_entry = FileEntry(filename="foo",
                                    path="imaginary",
                                    md5="123",
                                    sha1="234",
                                    sha256="345")

        assert test_file_entry.analyzed_at is None
        assert test_file_entry.contains_adware is None
        assert test_file_entry.contains_malware is None
        assert test_file_entry.contains_trackers is None


# ============================================= testing FileEntryCache =============================================


class TestFileEntryCache:
    def test_file_in_FileEntryCache(self, setup_empty_db):
        # GIVEN an empty datebase
        #       and a FileEntry

        # WHEN FileEntry is inserted into cache
        CACHE.insert(EX['FILE_ENTRY_NOT_YET_IN_CACHE'])

        # THEN file should be in cache
        assert EX['FILE_ENTRY_NOT_YET_IN_CACHE'] in CACHE

    def test_file_not_in_FileEntryCache(self, setup_empty_db):
        # GIVEN an empty database
        #       and a FileEntry

        # WHEN cache is asked if it contains FileEntry
        entry_in_cache = EX['FILE_ENTRY_NEVER_IN_CACHE'] in CACHE

        # THEN it should not be in cache
        assert not entry_in_cache

    @pytest.mark.skip(reason='have not found a way to monkeypatch 2nd datetime, probably will have to use mock instead')
    def test_file_in_FileEntryCache_was_analyzed(self, setup_empty_db):
        # GIVEN an empty database
        #       and a FileEntry

        # WHEN FileEntry is uploaded to cache
        CACHE.insert(test_entry)

        # THEN it should contain the correct time for 'analyzed_at'
        assert CACHE.was_analyzed(test_entry)

    def test_file_not_in_FileEntryCache_was_not_analyzed(self, setup_non_empty_db):
        # GIVEN e database with some FileEntry(s)
        #       and a FileEntry which is not in the database

        # WHEN we ask the database if the file has already been analyzed before
        already_analyzed = CACHE.was_analyzed(EX['FILE_ENTRY_NEVER_IN_CACHE'])

        # THEN the database should tell us that it wasn't analyzed before
        assert not already_analyzed

    def test_FileEntryCache_lookup_count_is_zero(self, setup_empty_db):
        # GIVEN e database with some FileEntry(s)
        #       and a FileEntry which is not in the database

        # WHEN we ask the database if the file has already been analyzed before
        lookup_count = CACHE._lookup_count(EX['FILE_ENTRY_NEVER_IN_CACHE'])

        # THEN the database should tell us that it wasn't analyzed before

        assert  lookup_count == 0

    def test_FileEntryCache_lookup_count_is_one(self, setup_empty_db):
        # GIVEN an empty database
        #       and a FileEntry which is not in the database

        # WHEN we upload the file twice and ask the database to count how often it contains that file
        CACHE.insert(EX['FILE_ENTRY_NOT_YET_IN_CACHE'])
        CACHE.insert(EX['FILE_ENTRY_NOT_YET_IN_CACHE'])

        # THEN the database should tell us that the file is in the database exactly one time
        assert CACHE._lookup_count(EX['FILE_ENTRY_NOT_YET_IN_CACHE']) == 1

    def test_FileEntryCache_duplicate_input_results_in_unsuccessful_insert(self, setup_non_empty_db):
        # GIVEN a database already containing some file(s)
        #       and a FileEntry which is already in that database

        # WHEN we upload the file again
        assert EX['FILE_ENTRY_IN_DB_WITH_FIRST_SEEN_AND_ALREADY_ANALYZED'] in CACHE  # sanity check

        # THEN the database should tell us that the file is in the database exactly one time
        assert CACHE.insert(EX['FILE_ENTRY_IN_DB_WITH_FIRST_SEEN_AND_ALREADY_ANALYZED']) is False

    def test_FileEntryCache_invalid_input_results_in_unsuccessful_insert(self, setup_empty_db):
        # GIVEN an empty database

        # WHEN a string is inserted into the database instead of a valid file
        not_a_file = "this is not a valid FileEntry"
        result = CACHE.insert(not_a_file)

        # THEN insert returns False  # TODO: should this raise an error?
        assert result is False

    def test_FileEntryCache_valid_input_successful_insert(self, setup_empty_db):
        # GIVEN an empty database
        #       and a FileEntry

        # WHEN inserting the FileEntry into the database
        result = CACHE.insert(EX['FILE_ENTRY_NOT_YET_IN_CACHE'])

        # THEN the return value for insert is True
        assert result is True

    def test_FileCacheEntry_dunder_len_on_empty_db(self, setup_empty_db):
        # GIVEN an empty database

        # WHEN asking for the length of that database with __len__
        length_empty_db = len(CACHE)

        # THEN the answer should be zero
        assert length_empty_db == 0

    def test_FileCacheEntry_dunder_len_on_non_empty_db(self, setup_non_empty_db):
        # GIVEN a non-empty database (containing 2 files)

        # WHEN asking for the length of that database with __len__
        length_non_empty_db = len(CACHE)

        # THEN the result should be two
        assert length_non_empty_db == 2

    @pytest.mark.xfail(reason="datetime.datetime.now() is called somewhere where it\'s not monkeypatched")
    def test_FileCacheEntry_get_cached_results(self, setup_non_empty_db):
        # GIVEN a non empty database (containing 2 files)

        # WHEN asking for all the items in that database
        result = CACHE.items()

        # THEN the response should be 2 files

        # this is the actual returned result from the call:
        assert result is [('bar', 'highway/to/hell', '12', '23', '34', False, False, True,
                           datetime.datetime(2020, 1, 26, 0, 42, 8, 583826, tzinfo=psycopg2.tz.FixedOffsetTimezone(offset=60, name=None)),
                           datetime.datetime(2001, 1, 1, 2, 2, 2, tzinfo=psycopg2.tz.FixedOffsetTimezone(offset=60, name=None))),
                          ('bar', 'stairway/to/heaven', '14', '25', '36', False, False, True,
                           datetime.datetime(2020, 1, 26, 0, 42, 8, 586506, tzinfo=psycopg2.tz.FixedOffsetTimezone(offset=60, name=None)), None)]

        # TODO: figure out a way to monkeypatch datetime call

