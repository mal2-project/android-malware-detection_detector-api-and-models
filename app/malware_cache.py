#!/usr/bin/env python

import json
import datetime
import psycopg2
import logging
from typing import Optional
from config import *

import copy


class FileEntry():
    filename: str
    path: str
    md5: str
    sha1: str
    sha256: str                     # for us, the sha256 is the primary key
    contains_malware: Optional[float]
    contains_trackers: Optional[float]
    contains_adware: Optional[float]
    first_seen: Optional[datetime.datetime]
    analyzed_at: Optional[datetime.datetime]

    def __init__(self,
                 filename: str,
                 path: str,
                 md5: str,
                 sha1: str,
                 sha256: str,
                 contains_malware: float = -1.0,
                 contains_trackers: float = -1.0,
                 contains_adware: float = -1.0):
        self.filename = filename
        self.path = path
        self.md5 = md5
        self.sha1 = sha1
        self.sha256 = sha256
        self.contains_malware = contains_malware
        self.contains_trackers = contains_trackers
        self.contains_adware = contains_adware
        self.first_seen = datetime.datetime.now()
        self.analyzed_at = None

    def __hash__(self):
        return self.sha256

    def __eq__(self, other):
        return self.sha256 == other.sha256

    def __ne__(self, other):
        return not (self == other)

    def __str__(self):
        return json.dumps({
            'filename': self.filename,
            'path': self.path,
            'md5': self.md5,
            'sha1': self.sha1,
            'sha256': self.sha256,
            'contains_malware': self.contains_malware,
            'contains_trackers': self.contains_trackers,
            'contains_adware': self.contains_adware,
            'first_seen': str(self.first_seen),
            'analyzed_at': str(self.analyzed_at)
        })

    def __repr__(self):
        return self.__str__()


class FileEntryCache():
    """
    The file Entry Cache stores all analysed entries
    """
    db_conn = None

    def __init__(self, db_backend="postgresql"):
        """
        Create a new FileEntry cache. By default the cache will be backed by postgresql.
        Redis will follow in the future.
        """
        try:
            self.db_conn = psycopg2.connect(dbname=config['DATABASE'],
                                            user=config['USERNAME'],
                                            password=config['PASSWORD'],
                                            host=config['DBHOST'])
            self.db_conn.set_session(autocommit=True)
        except Exception as ex:
            logging.error("could not connect to the database. Reason %s" % str(ex))
            raise

    def __del__(self):
        self.db_conn.close()

    def __contains__(self, entry: FileEntry) -> bool:
        return (self._lookup_count(entry) > 0)

    def was_analyzed(self, entry: FileEntry) -> bool:
        return entry in self

    def _lookup_count(self, entry: FileEntry) -> int:
        SQL = 'SELECT count(*) from "cache" WHERE sha256 = %s'
        try:
            cur = self.db_conn.cursor()
            cur.execute(SQL, (entry.sha256,))
            rows = cur.fetchall()
            if cur.rowcount > 0:
                return int(rows[0][0])
            else:
                return 0
        except Exception as ex:
            logging.error("Could not lookup %r. Reason: %s" % (str(entry), str(ex)))
            return 0

    def insert(self, entry: FileEntry) -> bool:
        """ inserts an entry into the BinCache """
        e = entry
        SQL = '''INSERT INTO "cache" (
                    filename,
                    path_on_disk,
                    md5,
                    sha1,
                    sha256,
                    contains_malware,
                    contains_trackers,
                    contains_adware,
                    first_seen,
                    analyzed_at
                )
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, now(), %s)'''
        try:
            cur = self.db_conn.cursor()
            print(cur.mogrify(SQL, (e.filename, e.path, e.md5, e.sha1, e.sha256, e.contains_malware, e.contains_trackers, e.contains_adware, e.analyzed_at)))
            cur.execute(SQL, (e.filename, e.path, e.md5, e.sha1, e.sha256, e.contains_malware, e.contains_trackers, e.contains_adware, e.analyzed_at))
            if 1 != cur.rowcount:  # did not update anything at all actually
                logging.warning("insert(): did not insert fileEntry %r" % str(e))
            else:
                logging.info("insert(): success")
                # self.db_conn.commit()     # XXX have autocommit
                return True
        except Exception as ex:
            logging.error("could not insert into DB. Reason: %s" % (str(ex),))
            self.db_conn.rollback()
        return False

    def items(self) -> []:
        """ returns the DB entries. """
        SQL = '''SELECT
              filename,path_on_disk as path, md5, sha1, sha256, contains_malware, contains_trackers, contains_adware, first_seen, analyzed_at
              FROM "cache"'''
        try:
            cur = self.db_conn.cursor()
            cur.execute(SQL)
            rows = cur.fetchall()
            return rows
        except Exception as ex:
            logging.error("Could not SELECT *. Reason: %s" % str(ex))
            return []

    def __len__(self) -> int:
        """ returns the number of DB entries. """
        SQL = 'SELECT count(*) from "cache"'
        try:
            cur = self.db_conn.cursor()
            cur.execute(SQL)
            rows = cur.fetchall()
            if cur.rowcount > 0:
                return int(rows[0][0])
            else:
                return 0
        except Exception as ex:
            logging.error("Could not SELECT count(*). Reason: %s" % str(ex))
            return 0

    def contains_malware(self, entry: FileEntry) -> bool:
        """
        Returns the result of the cache of the given entry
        @param entry: entry
        @return bool: is malware Y/N? Or None if not known
        """
        (contains_malware, _contains_trackers, _contains_adware) = self.get_cached_result(entry)
        return contains_malware

    def contains_trackers(self, entry: FileEntry) -> bool:
        """
        Returns the result of the cache of the given entry
        @param entry: entry
        @return bool: is malware Y/N? Or None if not known
        """
        (_contains_malware, contains_trackers, _contains_adware) = self.get_cached_result(entry)
        return contains_trackers

    def contains_adware(self, entry: FileEntry) -> bool:
        """
        Returns the result of the cache of the given entry
        @param entry: entry
        @return bool: is adware Y/N? Or None if not known
        """
        (_contains_malware, _contains_trackers, contains_adware) = self.get_cached_result(entry)
        return contains_adware

    def get_cached_result(self, entry: FileEntry) -> (bool, bool, bool):
        """
        Returns the result of the cache of the given entry
        @param entry: entry
        @return a tuple of  bools (contains_malware? Y/N, contains_trackers, contains_adware )
            or None if there was no match
        """
        SQL = 'SELECT contains_malware, contains_trackers, contains_adware from cache WHERE sha256 = %s'
        try:
            cur = self.db_conn.cursor()
            print(cur.mogrify(SQL, (entry.sha256,)))
            cur.execute(SQL, (entry.sha256,))
            rows = cur.fetchall()
            if cur.rowcount > 0:
                return (bool(rows[0][0]), bool(rows[0][1]), bool(rows[0][2]))
            else:
                return None
        except Exception as ex:
            logging.error("Could not lookup cached result %r. Reason: %s" % (str(entry), str(ex)))
            return None

    def is_empty(self):
        """stub to allow replacement by pytest during testing"""
        # TODO: find better solution

    def reset_table(self):
        """stub to allow replacement by pytest during testing"""
        # TODO: find better solution


if __name__ == "__main__":
    print("testing __init__():")
    e1 = FileEntry(filename="foo",
                      path="",
                      md5="42",
                      sha1="42",
                      sha256="42",
                      contains_malware=1.0,
                      contains_trackers=0.0,
                      contains_adware=0.0)
    print("testing __str__():")
    # print(str(e1))

    e2 = copy.copy(e1)
    e2.filename = "bar"
    e2.sha1 = 43
    e2.sha256 = 43
    e2.md5 = 43
    e3 = e2         # assign as reference

    print("testing __eq__ operator:")
    print("e1 == e2 ? %r  (expected result: False)" %(e1 == e2))
    print("e1 == e3 ? %r  (expected result: False)" %(e1 == e3))
    print("e2 == e3 ? %r  (expected result: True)" %(e2 == e3))
    print("e2 != e3 ? %r  (expected result: False)" %(e2 != e3))

    print("testing hashing:")
    print("hash(e1) = %s" % e1.__hash__())

    print("testing cache")
    cache = FileEntryCache()
    print("testing inserting")
    cache.insert(e1)
    cache.insert(e2)

    print("testing __contains__()")
    if e1 in cache:
        print("found entry %s in cache" % e1)
    entry2 = copy.copy(e1)
    entry2.sha256 = "45"
    try:
        assert entry2 in cache
    except:
        print("did not find entry2 in cache. As expected")
        pass
    else:
        print("oops, I think we found it in the cache, which was not expected")

    print("testing len() function")
    print("we have %d entries in the DB" % len(cache))

    # checking analysis cache
    print("checking if 42 was analyzed. Expecting True: %s" % (cache.was_analyzed(e1)))
    e4 = copy.copy(e1)
    e4.filename = "nonexistent",
    e4.md5 = "4444",
    e4.sha1 = "4444",
    e4.sha256 = "4444"
    print("checking if 4444 was analyzed. Expecting False: %s" % (cache.was_analyzed(e4)))

    print("testing dict / iterable iteration on cache:")
    for item in cache.items():
        print("%s" % str(item))

    print("testing if get_cached_result works:")
    cache.get_cached_result(e4)
